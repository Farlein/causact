#' Generate a representive sample of the posterior distribution
#'
#' The input graph object should be of class \code{causact_graph} and created using \code{dag_create()}.  The specification of a completely consistent joint distribution is left to the user.  Helpful error messages are scheduled for future versions of the \code{causact} package.
#'
#' @param graph a graph object of class \code{causact_graph} representing a complete and conistent specification of a joint distribution.
#' @param mcmc a logical value indicating whether to sample from the posterior distribution.  When \code{mcmc=FALSE}, the greta code is printed to the console, but not executed.  The user can cut and paste the code to another script for running line-by-line.  This option is most useful for debugging purposes. When \code{mcmc=TRUE}, the code is executed in the global environment.
#' @param meaningfulLabels a logical value indicating whether to replace the indexed variable names in \code{draws} with abbreviated names representing the factor value corresponding to the index.  This argument is treated as \code{TRUE} regardless of user input.  The ability to retain numerical indexing will be in a subsequent release.
#' @return If \code{mcmc=TRUE}, running \code{dag_greta} populates the global envirnment with all inputs required to run statistical inference using \code{greta} and more importantly, creates three objects in the global environment that represent the posterior distribution and other information generated by HMCMC.  The three objects are:
#' \enumerate{
#' \item \code{draws}:  An mcmc.list object containing raw output from the HMCMC sampler used by \code{greta}.
#' \item \code{drawsDF}:  A wide data frame with all latent variables as columns and all draws as rows.  This data frame is useful for calculations based on the posterior
#' \item \code{tidyDrawsDF}:  A long data frame with each draw represented on one line.  This data frame is useful for plotting posterior distributions.
#' }
#'
#' @examples
#' graph = dag_create() %>%
#'   dag_node("Get Card","y",
#'            rhs = bernoulli(theta),
#'            data = carModelDF$getCard) %>%
#'   dag_node(descr = "Card Probability by Car",label = "theta",
#'            rhs = beta(2,2),
#'            child = "y") %>%
#'   dag_node("Car Model","x",
#'            data = carModelDF$carModel,
#'            child = "y") %>%
#'   dag_plate("Car Model","x",
#'             data = carModelDF$carModel,
#'             nodeLabels = "theta")
#'
#' graph %>% dag_render()
#' graph %>% dag_greta()
#' graph %>% dag_render(shortLabel = TRUE)
#' graph %>% dag_greta(mcmc=TRUE)
#' tidyDrawsDF %>% dagp_plot()
#' @importFrom dplyr bind_rows tibble left_join select add_row as_tibble
#' @importFrom DiagrammeR create_graph add_global_graph_attrs
#' @importFrom rlang enquo expr_text
#' @importFrom igraph graph_from_data_frame topo_sort
#' @importFrom tidyr gather
#' @importFrom greta mcmc model as_data
#' @export
dag_greta <- function(graph,
                      mcmc = FALSE,
                      meaningfulLabels = TRUE,
                      ...) {

  ###get dimension information
  graph = graph %>% causact:::dag_dim()

  rhsPriorComposition = function(graph) {

    ## get nodes which have prior information
    nodeDF = graph$nodes_df %>%
      dplyr::filter(distr == TRUE) %>%
      select(id,rhs,rhsID)

    ## retireve non-NA argument list
    argDF = graph$arg_df %>%
      dplyr::filter(!is.na(argValue))

    ## get plate information for dim argument of priors
    plateDimDF = graph$plate_index_df %>%
      dplyr::filter(!is.na(dataNode)) %>% ##only plates with data
      dplyr::left_join(graph$plate_node_df, by = "indexID") %>%
      dplyr::select(nodeID,indexLabel)

    ## create label for the rhs for these nodes
    auto_rhsDF = nodeDF %>% dplyr::left_join(argDF, by = "rhsID") %>%
      dplyr::mutate(argValue = ifelse(is.na(argDimLabels),argValue,
                                      paste0(argValue,"[",
                                             ifelse(stringr::str_detect(argDimLabels,","),
                                                    paste0("cbind(", argDimLabels,")"),
                                                    argDimLabels),  ## use cbind for R indexing
                                             "]"))) %>% ## add extraction index to label
      dplyr::group_by(id,rhsID,rhs) %>%
      dplyr::summarize(args = paste0(argName," = ",argValue,collapse = ", ")) %>%
      dplyr::left_join(plateDimDF, by = c("id" = "nodeID")) %>%
      dplyr::mutate(indexLabel = ifelse(is.na(indexLabel) | indexLabel == "NA","",indexLabel)) %>%
      dplyr::mutate(indexLabel = ifelse(indexLabel == "","",paste0(indexLabel,"_dim"))) %>%
      dplyr::group_by(id,rhsID,rhs,args) %>%
      dplyr::summarize(indexLabel = paste0(indexLabel, collapse = ",")) %>%
      dplyr::mutate(indexLabel = ifelse(stringr::str_detect(indexLabel,","),
                                        paste0("c(",indexLabel,")"),
                                        indexLabel)) %>%
      dplyr::mutate(indexLabel = ifelse(indexLabel == "",as.character(NA),indexLabel)) %>%
      dplyr::mutate(prior_rhs = paste0(rhs,"(",args,
                                       ifelse(is.na(indexLabel),"",
                                              paste0(", dim = ",indexLabel)),
                                       ")")) %>%
      dplyr::ungroup() %>%
      select(id,prior_rhs)

    ##update graph with new label
    graph$nodes_df = graph$nodes_df %>% left_join(auto_rhsDF, by = "id") %>%
      mutate(auto_rhs = ifelse(is.na(prior_rhs),auto_rhs,prior_rhs)) %>%
      dplyr::select(-prior_rhs)

    return(graph) ##now has populated graph$nodes_df$auto_rhs for priors
  }

  rhsOperationComposition = function(graph) {
    graph$nodes_df$auto_rhs = ifelse(is.na(graph$nodes_df$auto_rhs) & graph$nodes_df$distr == FALSE & !is.na(graph$nodes_df$rhs),
                                     graph$nodes_df$rhs,
                                     graph$nodes_df$auto_rhs)

    ## update auto_rhs with dimensioned formulas
    ## get nodes with argDimLabels
    argDimLabelNodes = graph$arg_df %>%
      dplyr::filter(!is.na(argDimLabels)) %>%
      select(rhsID,argName,argDimLabels)

    ## only do if there arguments needing dim labels added
    if(nrow(argDimLabelNodes) > 0) { ##start if

      for(i in 1:nrow(argDimLabelNodes)){
        ### find index of node with matching rhsID
        nodePosition = which(graph$nodes_df$rhsID == argDimLabelNodes$rhsID[i])
        ### replace the string if it is a formula
        if(graph$nodes_df$distr[nodePosition] == FALSE &
           !is.na(graph$nodes_df$auto_rhs[nodePosition])) {
          graph$nodes_df$auto_rhs[nodePosition] =
            stringr::str_replace(graph$nodes_df$auto_rhs[nodePosition],
                                 argDimLabelNodes$argName[i],
                                 paste0(argDimLabelNodes$argName[i],
                                        "[",
                                        argDimLabelNodes$argDimLabels[i],
                                        "]"))
        }
      }  ## end for loop
    } ## end if

    return(graph)
  }
  ###update rhs information for labelling computer code
  graph = rhsPriorComposition(graph)
  graph = rhsOperationComposition(graph)

  ###retrieve nodeDF,edgeDF,argDF,plateIndexDF, and plateNodeDF
  nodeDF = graph$nodes_df
  edgeDF = graph$edges_df
  argDF = graph$arg_df
  plateDF = graph$plate_index_df
  plateNodeDF = graph$plate_node_df
  dimDF = graph$dim_df

  ###arrangeNodes in topological order -> top-down
  nodeIDOrder = igraph::graph_from_data_frame(edgeDF %>% dplyr::select(from,to)) %>%
    igraph::topo_sort(mode = "out") %>%
    names() %>%
    as.integer()

  ## append non-connected nodes into nodeIDOrder
  nodeIDOrder = union(nodeIDOrder,nodeDF$id)

  ## arrange nodeDF by nodeIDOrder
  nodeDF = nodeDF[match(nodeIDOrder,nodeDF$id) , ] %>%
    dplyr::mutate(nodeOrder = row_number())

  ###Use DAPROPLIMOPO(DAta,PRior,OPeration,LIkelihood,MOdel,POsterior)
  ###Find all nodes that require data based on user input
  ###Err on the side of including a node

  ### Initialize all the code statements so that NULL
  ### values are skipped without Error
  dataStatements = NULL
  plateDataStatements = NULL
  dimStatements = NULL
  priorStatements = NULL
  opStatements = NULL
  likeStatements = NULL
  # use priorOpLikeDF to use topological order
  # for prior, operation, and likelihood statements
  priorOpLikeDF = data.frame(statement = as.character(NA),
                             orderID = as.integer(NA),
                             stringsAsFactors = FALSE)[-1,]
  priorOpLikeStatements = NULL
  modelStatement = NULL
  posteriorStatement = NULL


  ###DATA:  Create Code for Data Lines
  abbrevLabelPad <- function(stringVector) {
    maxStrWidth = max(nchar(stringVector), 6)
    padding = paste(rep(" ", maxStrWidth), collapse = "")
    paddedString = paste0(stringVector, padding)
    string = substr(paddedString, 1, maxStrWidth)
    return(string)
  }

  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE | !is.na(data)) %>%
    dplyr::filter(!(label %in% plateDF$indexLabel)) %>%
    dplyr::mutate(codeLine = paste0(auto_label,
                             " <- ",
                             "as_data(",
                             data,
                             ")")) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #DATA"))

  ###Aggregate Code Statements for DATA
  if(nrow(lhsNodesDF) > 0) {
    dataStatements = paste(lhsNodesDF$codeLine,
                           sep = "\n")
  }

  ###DIM:  Create code for plate dimensions
    plateDimDF = plateDF %>% dplyr::filter(!is.na(dataNode))
    if (nrow(plateDimDF) > 0) {
      plateDataStatements = paste(paste0(
        abbrevLabelPad(paste0(plateDimDF$indexLabel,
                              "    ")),# four spaces to have invis _dim
                              " <- ",
                              "as.factor(",
                              plateDimDF$dataNode,
                              ")   #DIM"
                                         ),
                              sep = "\n")
    ###make labels for dim variables = to label_dim
      dimStatements = paste(
        paste0(abbrevLabelPad(paste0(plateDimDF$indexLabel,
                                "_dim")),
               " <- ",
               "length(unique(",
               plateDimDF$indexLabel,
               "))   #DIM"
               ),
        sep = "\n"
      )
      }

  ### Prior, Operations, and Likelihood Get Sorted by Topological Order

  ###PRIOR:  Create code for prior lines
  ###create dataframe of dataNodes and their data


  #update auto_rhs to use cbind for R indexing if there is a comma in it

  lhsNodesDF = nodeDF %>%
    dplyr::filter(distr == TRUE & obs == FALSE) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(auto_label),
                             " <- ",
                             auto_rhs)) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #PRIOR"))

  ###Aggregate Code Statements for PRIOR
  priorStatements = paste(lhsNodesDF$codeLine,
                          sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = priorStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))

  ###OPERATION:  Create code for OPERATION lines
  lhsNodesDF = nodeDF %>%
    dplyr::filter(!is.na(rhs) & distr == FALSE) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(auto_label),
                             " <- ",
                             auto_rhs)) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #OPERATION"))

  ###Aggregate Code Statements for OPERATION
  opStatements = paste(lhsNodesDF$codeLine,
                       sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = opStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))

  ###LIKELIHOOD:  Create code for LIKELIHOOD lines
  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE) %>%  ##only observed nodes
    dplyr::inner_join(edgeDF, by = c("id" = "to")) %>% # only nodes with parents
    dplyr::distinct(id,auto_label,auto_rhs,nodeOrder) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(
      paste0("distribution(",
             auto_label,
             ")")
    ),
    " <- ",
    auto_rhs)) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #LIKELIHOOD"))

  ###Aggregate Code Statements for LIKELIHOOD
  likeStatements = paste(lhsNodesDF$codeLine,
                         sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = likeStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))

  ### Use topological ordering
  if(nrow(priorOpLikeDF) > 0){
    priorOpLikeStatements = priorOpLikeDF %>%
      dplyr::arrange(orderID) %>%
      dplyr::pull(statement)
  }

  ###Create MODEL Statement
  # get all non-observed / non-formula nodes by default
  unobservedNodes = graph$nodes_df %>%
    dplyr::filter(obs == FALSE & distr == TRUE) %>%
    dplyr::pull(auto_label)

  #group unobserved nodes by their rhs for later plotting by ggplot
  #all nodes sharing the same prior will be graphed on the same scale
  # this code should be moved out of dag_greta at some point
  priorGroupDF = graph$nodes_df %>%
    dplyr::filter(obs == FALSE & distr == TRUE) %>%
    dplyr::mutate(., priorGroup = group_indices(., auto_rhs))
  assign("priorGroupDF", priorGroupDF, envir = cacheEnv)

  modelStatement = paste0("gretaModel <- model(",
                          paste0(unobservedNodes, collapse = ","),
                          ")   #MODEL")

  ###Create POSTERIOR draws statement
  meaningfulLabels(graph)  ###assign meaningful labels in cacheEnv
  extraArgList = list(...)
  extraArgString = paste0(paste0(names(extraArgList)," = ", as.character(extraArgList)), collapse = ",")
  mcmcArgs = ifelse(extraArgString == " = ","gretaModel",paste("gretaModel",extraArgString, sep = ","))
  posteriorStatement = paste0("draws       <- mcmc(",mcmcArgs,")   #POSTERIOR\ndraws       <- replaceLabels(draws)   #POSTERIOR\ndrawsDF     <- draws %>% as.matrix() %>% dplyr::as_tibble()   #POSTERIOR\ntidyDrawsDF <- drawsDF %>% tidyr::gather() %>%
    addPriorGroups()   #POSTERIOR\n")

  ##########################################
  ###Aggregate all code
  codeStatements = c(dataStatements,
                     plateDataStatements,
                     dimStatements,
                     priorOpLikeStatements,
                     modelStatement,
                     posteriorStatement)

  #codeStatements

  ###gretaCode as text
  paste0("## The specified DAG corresponds to the following greta code: \n",
         paste(codeStatements, collapse = '\n')) %>% cat()

  ##EVALUATE CODE IN GLOBAL ENVIRONMENT
  ##make expression out of Code Statements
  codeExpr = parse(text = codeStatements)

  ##eval expression
  if(mcmc == TRUE) {eval(codeExpr, envir = globalenv())}

  ###return code
  return(invisible())
}
